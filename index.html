<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- é”å®šè§†å£ï¼Œç¦æ­¢ç¼©æ”¾ï¼Œé€‚é…ç§»åŠ¨ç«¯ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ‰‹åŠ¿ç²’å­ (æ‰‹æœºç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* å…³é”®ï¼šéšè—è§†é¢‘ä½†ä¿ç•™å ä½ï¼Œé˜²æ­¢ iOS å…¨å±å¼¹çª— */
        #input_video { 
            position: absolute; top: 0; left: 0; opacity: 0; z-index: -1; 
            width: 1px; height: 1px; pointer-events: none;
        }
        
        /* UI é¢æ¿ - é€‚é…æ‰‹æœºå®½åº¦ */
        #ui-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            left: 10px; /* æ‰‹æœºç«¯å·¦å³æ’‘å¼€ */
            max-width: 400px; /* å¹³æ¿/ç”µè„‘é™åˆ¶æœ€å¤§å®½åº¦ */
            margin: 0 auto;
            padding: 15px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            z-index: 100;
            transition: opacity 0.3s;
            max-height: 25vh; /* é˜²æ­¢é®æŒ¡å¤ªå¤šï¼Œå†…å®¹å¯æ»šåŠ¨ */
            overflow-y: auto;
        }

        /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™åŠŸèƒ½ */
        #ui-panel::-webkit-scrollbar { width: 0; }

        h2 { margin: 0 0 10px 0; font-size: 16px; text-align: center; letter-spacing: 1px; color: #00ffc8; }
        
        .control-group { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; }
        label { font-size: 13px; opacity: 0.8; margin-right: 10px; min-width: 60px; }
        
        /* æŒ‰é’®æ»šåŠ¨å®¹å™¨ */
        .btn-scroll { 
            display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px; 
            flex: 1;
        }
        
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            color: white;
            border-radius: 20px;
            white-space: nowrap;
            font-size: 12px;
            flex-shrink: 0;
        }
        button.active { background: #00ffc8; color: #000; font-weight: bold; }
        
        input[type="color"] {
            width: 40px; height: 30px; border: none; background: none; padding: 0;
        }

        #status {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.5); font-size: 12px; pointer-events: none;
            text-shadow: 0 1px 2px #000;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffc8; font-size: 20px; z-index: 200; text-align: center;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–ç›¸æœº...<br><span style="font-size:12px; color:#fff">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>

    <div id="ui-panel">
        <div class="control-group">
            <label>å½¢çŠ¶</label>
            <div class="btn-scroll">
                <button onclick="setShape('heart')" class="active" id="btn-heart">â¤ï¸ çˆ±å¿ƒ</button>
                <button onclick="setShape('saturn')" id="btn-saturn">ğŸª åœŸæ˜Ÿ</button>
                <button onclick="setShape('flower')" id="btn-flower">ğŸŒ¸ èŠ±æœµ</button>
                <button onclick="setShape('buddha')" id="btn-buddha">ğŸ§˜ ä½›åƒ</button>
                <button onclick="setShape('fireworks')" id="btn-fireworks">ğŸ† çƒŸèŠ±</button>
            </div>
        </div>
        <div class="control-group">
            <label>é¢œè‰²</label>
            <input type="color" id="colorPicker" value="#00ffc8">
            <label style="margin-left:auto; min-width:auto" onclick="toggleUI()">ğŸ”½ æ”¶èµ·</label>
        </div>
    </div>

    <div id="status">ç­‰å¾…æ‰‹åŠ¿... (æåˆæ‰‹æŒ‡)</div>
    
    <!-- å…³é”®å±æ€§ï¼šplaysinline webkit-playsinline é€‚é… iOS -->
    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>

<script>
    // ================= é€‚é…æ‰‹æœºçš„é…ç½® =================
    const PARTICLE_COUNT = 15000; // é™ä½ç²’å­æ•°ä»¥ä¿è¯æ‰‹æœºæµç•…åº¦
    const PARTICLE_SIZE = 0.2;
    let currentShape = 'heart';
    let handInteractionFactor = 1.0;
    let targetColor = new THREE.Color(0x00ffc8);

    // ================= THREE.JS =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25; // æ‰‹æœºå±å¹•å°ï¼Œæ‹‰è¿‘ä¸€ç‚¹è·ç¦»

    const renderer = new THREE.WebGLRenderer({ antialias: false }); // å…³é—­æŠ—é”¯é½¿æé«˜æ€§èƒ½
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”
    document.body.appendChild(renderer.domElement);

    // ================= ç²’å­ç³»ç»Ÿ =================
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        color: targetColor,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // ================= å½¢çŠ¶ç®—æ³• (ç®€åŒ–ç‰ˆ) =================
    function getPointOnSphere(r) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
    }

    const Shapes = {
        heart: (i) => {
            const t = Math.random() * Math.PI * 2, u = Math.random() * Math.PI;
            const x = 16 * Math.pow(Math.sin(u), 3) * Math.sin(t);
            const y = (13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u));
            const z = 16 * Math.pow(Math.sin(u), 3) * Math.cos(t) * 0.5;
            return [x * 0.6, y * 0.6, z * 0.6];
        },
        saturn: (i) => {
            if (Math.random() > 0.4) {
                const angle = Math.random() * Math.PI * 2, dist = 9 + Math.random() * 4;
                return [Math.cos(angle) * dist, (Math.random()-0.5)*0.5, Math.sin(angle) * dist];
            }
            const p = getPointOnSphere(5); return [p.x, p.y, p.z];
        },
        flower: (i) => {
            const u = Math.random() * Math.PI * 4, v = Math.random() * Math.PI * 2;
            const rad = 8 * Math.sin(3 * u);
            return [rad * Math.sin(u) * Math.cos(v), rad * Math.cos(u) * Math.cos(v) + 4, rad * Math.sin(v)];
        },
        buddha: (i) => {
            const r = Math.random();
            let p, yOffset;
            if (r < 0.25) { p = getPointOnSphere(2); yOffset = 6; }
            else if (r < 0.65) { p = getPointOnSphere(4.5); p.y*=0.8; yOffset = 1; }
            else { p = getPointOnSphere(6); p.y*=0.4; yOffset = -4; }
            return [p.x, p.y + yOffset, p.z];
        },
        fireworks: () => { const p = getPointOnSphere(Math.random() * 15); return [p.x, p.y, p.z]; }
    };

    function calculateTargetPositions(shapeName) {
        const generator = Shapes[shapeName];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const pos = generator(i);
            targetPositions[i * 3] = pos[0];
            targetPositions[i * 3 + 1] = pos[1];
            targetPositions[i * 3 + 2] = pos[2];
        }
    }
    calculateTargetPositions('heart');

    // ================= äº¤äº’ =================
    window.setShape = (name) => {
        currentShape = name;
        calculateTargetPositions(name);
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${name}`).classList.add('active');
        
        let hex = '#00ffc8';
        if (name === 'buddha') hex = '#ffcc00';
        if (name === 'heart') hex = '#ff0055';
        document.getElementById('colorPicker').value = hex;
        targetColor.set(hex);
    };

    document.getElementById('colorPicker').addEventListener('input', (e) => targetColor.set(e.target.value));

    window.toggleUI = () => {
        const ui = document.getElementById('ui-panel');
        ui.style.opacity = ui.style.opacity === '0' ? '1' : '0';
    };

    // ================= MediaPipe Hands (é’ˆå¯¹æ‰‹æœºä¼˜åŒ–) =================
    const videoElement = document.getElementById('input_video');
    let isHandDetected = false;

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // é™ä½æ¨¡å‹å¤æ‚åº¦ä»¥æé«˜æ‰‹æœºFPS
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            document.getElementById('status').innerText = "ğŸ– å·²æ•æ‰æ‰‹åŠ¿";
            const lm = results.multiHandLandmarks[0];
            const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
            
            // æ‰‹æœºæ‘„åƒå¤´è·ç¦»è„¸è¾ƒè¿‘ï¼Œå‚æ•°å¾®è°ƒ
            let normalized = (dist - 0.02) / (0.15 - 0.02);
            normalized = Math.max(0, Math.min(1, normalized));
            const target = 0.3 + (normalized * 2.0);
            handInteractionFactor += (target - handInteractionFactor) * 0.1;
        } else {
            isHandDetected = false;
            document.getElementById('status').innerText = "ğŸ‘€ æœªæ£€æµ‹åˆ°æ‰‹ (è¯·ä¸¾èµ·æ‰‹)";
            handInteractionFactor += (1.0 - handInteractionFactor) * 0.05;
        }
    });

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480,
        facingMode: 'user' // å¼ºåˆ¶ä½¿ç”¨å‰ç½®æ‘„åƒå¤´
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;
        material.color.lerp(targetColor, 0.05);
        particles.rotation.y = time * 0.1;
        
        const posArr = particles.geometry.attributes.position.array;
        const isFireworks = currentShape === 'fireworks';
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3, iy = ix + 1, iz = ix + 2;
            let tx = targetPositions[ix], ty = targetPositions[iy], tz = targetPositions[iz];

            if (isFireworks) {
                const pulse = 1 + Math.sin(time * 3) * 0.5;
                tx *= pulse; ty *= pulse; tz *= pulse;
            }

            tx *= handInteractionFactor; ty *= handInteractionFactor; tz *= handInteractionFactor;
            
            // ç®€å•å™ªç‚¹
            tx += (Math.random()-0.5)*0.2; ty += (Math.random()-0.5)*0.2; tz += (Math.random()-0.5)*0.2;

            posArr[ix] += (tx - posArr[ix]) * 0.1;
            posArr[iy] += (ty - posArr[iy]) * 0.1;
            posArr[iz] += (tz - posArr[iz]) * 0.1;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
</script>
</body>
</html>
